// SLOPCHOP TYPE SIGNATURES
// Files ordered: Base Dependencies → Top-Level Consumers
// Tier Key: [CORE] = high PageRank, [LOW] = leaf node
// ======================================================

// ======================================================
// src/config/locality.rs  [LOW]
// ======================================================
pub struct LocalityConfig {
    /// Maximum D for non-Hub dependencies. Default: 4
    pub max_distance: usize,
    /// Threshold for L1 cache (always pass). Default: 2
    pub l1_threshold: usize,
    /// Minimum K (skew) to qualify as Hub. Default: 1.0
    pub hub_threshold: f64,
    /// Minimum Cₐ for Hub status. Default: 5
    pub min_hub_afferent: usize,
    /// Cₐ AND Cₑ above this = God Module. Default: 20
    pub god_module_threshold: usize,
    /// Cₐ + Cₑ below this = Deadwood. Default: 2
    pub deadwood_threshold: usize,
    /// Enforcement mode: "error", "warn", or "off"
    pub mode: String,
    /// Glob patterns to exempt from checks
    #[serde(default)]
    pub exempt_patterns: Vec<String>,
}
impl Default for LocalityConfig { ... }
impl LocalityConfig { ... }


// ======================================================
// src/analysis/metrics.rs
// ======================================================
/// Calculates the nesting depth of a node.
#[must_use]
pub fn calculate_max_depth(node: Node) -> usize { ... }
/// Calculates `McCabe` Cyclomatic Complexity.
#[must_use]
pub fn calculate_complexity(node: Node, source: &str, query: &Query) -> usize { ... }
/// Counts named arguments/parameters.
#[must_use]
pub fn count_arguments(node: Node) -> usize { ... }


// ======================================================
// src/analysis/extract.rs  [LOW]
// ======================================================
pub struct RustExtractor;
impl RustExtractor { ... }


// ======================================================
// src/analysis/structural.rs
// ======================================================
pub struct ScopeMetrics;
impl ScopeMetrics { ... }


// ======================================================
// src/project.rs  [LOW]
// ======================================================
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ProjectType {
    Rust,
    Node,
    Python,
    Go,
    Unknown,
}
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Strictness {
    Strict,
    Standard,
    Relaxed,
}
impl ProjectType { ... }
#[must_use]
pub fn generate_toml(project: ProjectType, strictness: Strictness) -> String { ... }
#[must_use]
pub fn npx_cmd() -> &'static str { ... }


// ======================================================
// src/cli/args.rs  [LOW]
// ======================================================
pub struct Cli {
    #[command(subcommand)]
    pub command: Option<Commands>,
}
#[derive(Subcommand)]
pub enum Commands {
    /// Run structural checks on the codebase
    Check {
        /// Output results as JSON
        #[arg(long)]
        json: bool,
    },

    /// Scan for violations
    Scan {
        #[arg(long, short)]
        verbose: bool,
        /// Run topology/locality analysis [EXPERIMENTAL]
        #[arg(long, short)]
        locality: bool,
        /// Output results as JSON
        #[arg(long)]
        json: bool,
    },

    /// Create or reset the work branch
    Branch {
        #[arg(long, short)]
        force: bool,
    },

    /// Promote work branch to main
    Promote {
        #[arg(long)]
        dry_run: bool,
    },

    /// Abort work branch and return to main
    Abort,

    /// Clean up artifacts
    Clean {
        #[arg(long, short)]
        commit: bool,
    },

    /// Generate type-surface signatures [EXPERIMENTAL]
    Signatures {
        #[arg(long, short)]
        copy: bool,
        #[arg(long, short)]
        stdout: bool,
    },

    /// Interactive configuration editor
    Config,

    /// Run mutation testing to find test gaps [EXPERIMENTAL]
    Mutate {
        /// Number of parallel workers (reserved for future use)
        #[arg(long, short)]
        workers: Option<usize>,
        /// Test timeout in seconds
        #[arg(long, default_value = "30")]
        timeout: u64,
        /// Output results as JSON
        #[arg(long)]
        json: bool,
        /// Filter files by path pattern
        #[arg(long, short)]
        filter: Option<String>,
    },
}


// ======================================================
// src/utils.rs
// ======================================================
/// Computes SHA256 hash of content with normalized line endings.
/// Always normalizes CRLF/CR to LF before hashing to ensure consistent
/// hashes across Windows/Unix platforms.
#[must_use]
pub fn compute_sha256(content: &str) -> String { ... }


// ======================================================
// src/analysis/patterns/concurrency_lock.rs  [LOW]
// ======================================================
/// C03: `MutexGuard` held across `.await`
#[must_use]
pub fn detect_c03(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/config/io.rs
// ======================================================
pub fn load_ignore_file(config: &mut Config) { ... }
pub fn process_ignore_line(config: &mut Config, line: &str) { ... }
pub fn load_toml_config(config: &mut Config) { ... }
pub fn parse_toml(config: &mut Config, content: &str) { ... }
pub fn apply_project_defaults(config: &mut Config) { ... }
pub fn save_to_file(
    rules: &RuleConfig,
    prefs: &Preferences,
    commands: &HashMap<String, Vec<String>>,
) -> Result<()> { ... }


// ======================================================
// src/cli/audit.rs  [LOW]
// ======================================================
pub struct AuditCliOptions<'a> {
    pub format: &'a str,
    pub no_dead: bool,
    pub no_dups: bool,
    pub no_patterns: bool,
    pub min_lines: usize,
    pub max: usize,
    pub verbose: bool,
}
/// Runs the consolidation audit with the given options.
///
/// # Errors
/// Returns error if audit fails.
pub fn handle(opts: &AuditCliOptions<'_>) -> Result<()> { ... }


// ======================================================
// src/graph/locality/analysis/violations.rs  [LOW]
// ======================================================
/// Categories of locality violations.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ViolationKind {
    /// Importing module internals instead of public API.
    EncapsulationBreach,
    /// File depends on too many distant modules.
    GodModule,
    /// Target has high fan-in but isn't recognized as Hub.
    MissingHub,
    /// Generic sideways dependency.
    SidewaysDep,
    /// Dependency flows upwards (Lower Layer -> Higher Layer).
    UpwardDep,
}
impl ViolationKind { ... }
/// A categorized violation with actionable suggestion.
#[derive(Debug, Clone)]
pub struct CategorizedViolation {
    pub edge: LocalityEdge,
    pub kind: ViolationKind,
    pub suggestion: String,
}
pub fn categorize_violation(
    edge: &LocalityEdge,
    couplings: &HashMap<PathBuf, Coupling>,
    layers: &HashMap<PathBuf, usize>,
) -> ViolationKind { ... }


// ======================================================
// src/spinner/state.rs  [LOW]
// ======================================================
pub const ATOMIC_LINES: usize = 5;
pub struct HudState {
    pipeline_title: String,
    pipeline_step: Option<(usize, usize)>,
    step_name: String,
    micro_status: String,
    micro_progress: Option<(usize, usize)>,
    atomic_buffer: VecDeque<String>,
    start_time: Instant,
    final_success: Option<bool>,
    activity_tick: usize,
}
pub struct HudSnapshot {
    pub pipeline_title: String,
    pub pipeline_step: Option<(usize, usize)>,
    pub step_name: String,
    pub micro_status: String,
    pub micro_progress: Option<(usize, usize)>,
    pub atomic_buffer: VecDeque<String>,
    pub start_time: Instant,
    pub activity_tick: usize,
}
impl Default for HudSnapshot { ... }
impl HudState { ... }


// ======================================================
// src/graph/rank/graph.rs  [LOW]
// ======================================================
/// The dependency graph and ranker.
#[derive(Clone)]
pub struct RepoGraph {
    pub(crate) tags: Vec<crate::graph::rank::tags::Tag>,
    pub(crate) defines: HashMap<String, HashSet<PathBuf>>,
    /// References map: Symbol -> Set of files that reference it.
    /// Changed from `Vec` to `HashSet` to ensure O(1) lookups and fix P06 violations.
    pub(crate) references: HashMap<String, HashSet<PathBuf>>,
    pub(crate) ranks: HashMap<PathBuf, f64>,
}
impl RepoGraph { ... }


// ======================================================
// src/graph/rank/tags.rs
// ======================================================
/// A tag representing either a definition or a reference.
#[derive(Debug, Clone)]
pub struct Tag {
    pub file: PathBuf,
    pub name: String,
    pub kind: TagKind,
    pub line: usize,
    pub signature: Option<String>,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TagKind {
    Def,
    Ref,
}


// ======================================================
// src/mutate/report.rs
// ======================================================
/// Formats a progress update for terminal output.
#[must_use]
pub fn format_progress(current: usize, total: usize, result: &MutationResult) -> String { ... }
/// Formats the final summary report.
#[must_use]
pub fn format_summary(summary: &MutationSummary) -> String { ... }
/// Formats the surviving mutants report.
#[must_use]
pub fn format_survivors(results: &[MutationResult]) -> String { ... }
/// Formats results as JSON for machine consumption.
#[must_use]
pub fn format_json(results: &[MutationResult], summary: &MutationSummary) -> String { ... }


// ======================================================
// src/reporting.rs
// ======================================================
/// Prints a formatted scan report to stdout.
///
/// # Errors
/// Returns error if formatting fails.
pub fn print_report(report: &ScanReport) -> Result<()> { ... }
/// Formats a report as a string (for embedding in context files).
///
/// # Errors
/// Returns error if formatting fails.
pub fn format_report_string(report: &ScanReport) -> Result<String> { ... }
/// Prints a serializable object as JSON to stdout.
///
/// # Errors
/// Returns error if serialization fails.
pub fn print_json<T: serde::Serialize>(data: &T) -> Result<()> { ... }


// ======================================================
// src/spinner/safe_hud.rs  [LOW]
// ======================================================
/// Thread-safe wrapper around `HudState`.
/// Encapsulates locking to reduce coupling in consumers.
#[derive(Clone)]
pub struct SafeHud {
    /// Internal state protected by mutex.
    inner: Arc<Mutex<HudState>>,
}
impl SafeHud { ... }


// ======================================================
// src/events.rs
// ======================================================
pub enum EventKind {
    StageCreated {
        id: String,
    },
    StageReset,
    ApplyStarted,
    ApplySucceeded {
        files_written: usize,
        files_deleted: usize,
    },
    ApplyRejected {
        reason: String,
    },
    FileWritten {
        path: String,
        bytes: usize,
    },
    FileDeleted {
        path: String,
    },
    CheckStarted,
    CheckPassed,
    CheckFailed {
        exit_code: i32,
    },
    PromoteStarted,
    PromoteSucceeded {
        files_written: usize,
        files_deleted: usize,
    },
    PromoteFailed {
        error: String,
    },
    SanitizationPerformed {
        path: String,
        lines_removed: usize,
    },
}
#[derive(Debug, Serialize, Deserialize)]
pub struct SlopChopEvent {
    pub timestamp: u64,
    pub kind: EventKind,
}
#[derive(Clone)]
pub struct EventLogger {
    log_path: PathBuf,
}
impl EventLogger { ... }


// ======================================================
// src/constants.rs  [LOW]
// ======================================================
//! Shared constants for file filtering and pattern matching.

pub const PRUNE_DIRS: &[&str] = &[
    ".git",
    ".svn",
    ".hg",
    "node_modules",
    "target",
    "dist",
    "build",
    "out",
    "gen",
    ".venv",
    "venv",
    ".tox",
    "__pycache__",
    "coverage",
    "vendor",
    ".slopchop_apply_backup",
];
pub const PRUNE_FILES: &[&str] = &[
    "Cargo.lock",
    "package-lock.json",
    "pnpm-lock.yaml",
    "yarn.lock",
    "bun.lockb",
    "go.sum",
    "Gemfile.lock",
];
pub const SKIP_DIRS: &[&str] = &["spec", "examples", "fixtures"];
pub const BIN_EXT_PATTERN: &str =
    r"(?i)\.(png|jpg|gif|svg|ico|webp|woff2?|ttf|pdf|mp4|zip|gz|tar|exe|dll|so|dylib|class|pyc)$";
pub const SECRET_PATTERN: &str =
    r"(?i)(^\.?env(\..*)?$|/\.?env(\..*)?$|(^|/)(id_rsa|id_ed25519|.*\.(pem|p12|key|pfx))$)";
pub const CODE_EXT_PATTERN: &str = r"(?i)\.(rs|go|py|js|jsx|ts|tsx|java|c|cpp|h|hpp|cs|php|rb|sh|sql|html|css|scss|json|toml|yaml|md)$";
pub const CODE_BARE_PATTERN: &str = r"(?i)(Makefile|Dockerfile|CMakeLists\.txt)$";
/// Checks if a directory name should be pruned during traversal.
#[must_use]
pub fn should_prune(name: &str) -> bool { ... }


// ======================================================
// src/exit.rs  [LOW]
// ======================================================
pub enum SlopChopExit {
    /// Operation completed successfully.
    Success = 0,
    /// Generic error (e.g. IO, network, config).
    Error = 1,
    /// Input validation failed (Parser error, Protocol violation, Empty input).
    InvalidInput = 2,
    /// Security/Safety violation (Path traversal, Protected file, Symlink escape).
    SafetyViolation = 3,
    /// Patch application failed (Hash mismatch, Ambiguity, 0 matches).
    PatchFailure = 4,
    /// Promotion failed (Stage->Workspace write error).
    PromoteFailure = 5,
    /// Verification failed (Tests, Lints, or Structural Scan).
    CheckFailed = 6,
}
impl SlopChopExit { ... }
impl Termination for SlopChopExit { ... }
impl From<anyhow::Result<()>> for SlopChopExit { ... }


// ======================================================
// src/config/types.rs  [MID]
// ======================================================
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Preferences {
    #[serde(default = "default_auto_copy")]
    pub auto_copy: bool,
    #[serde(default)]
    pub auto_format: bool,
    #[serde(default)]
    pub system_bell: bool,
    #[serde(default = "default_backup_retention")]
    pub backup_retention: usize,
    #[serde(default = "default_progress_bars")]
    pub progress_bars: bool,
    #[serde(default)]
    pub require_plan: bool,
    #[serde(default)]
    pub write_fix_packet: bool,
    #[serde(default = "default_fix_packet_path")]
    pub fix_packet_path: String,
    #[serde(default)]
    pub auto_promote: bool,
}
impl Default for Preferences { ... }
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleConfig {
    #[serde(default = "default_max_tokens")]
    pub max_file_tokens: usize,
    #[serde(
        default = "default_max_complexity",
        alias = "max_cyclomatic_complexity"
    )]
    pub max_cognitive_complexity: usize,
    #[serde(default = "default_max_depth")]
    pub max_nesting_depth: usize,
    #[serde(default = "default_max_args")]
    pub max_function_args: usize,
    #[serde(default = "default_max_words")]
    pub max_function_words: usize,

    // Scan v2 Metrics
    #[serde(default = "default_lcom4")]
    pub max_lcom4: usize,
    #[serde(default = "default_ahf")]
    pub min_ahf: f64,
    #[serde(default = "default_cbo")]
    pub max_cbo: usize,
    #[serde(default = "default_sfout")]
    pub max_sfout: usize,

    #[serde(default)]
    pub ignore_naming_on: Vec<String>,
    #[serde(default = "default_ignore_tokens")]
    pub ignore_tokens_on: Vec<String>,
    #[serde(default)]
    pub safety: SafetyConfig,
    #[serde(default)]
    pub locality: super::locality::LocalityConfig,
}
impl Default for RuleConfig { ... }
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyConfig {
    #[serde(default = "default_true")]
    pub require_safety_comment: bool,
    #[serde(default)]
    pub ban_unsafe: bool,
}
impl Default for SafetyConfig { ... }
pub enum CommandEntry {
    Single(String),
    List(Vec<String>),
}
impl CommandEntry { ... }
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SlopChopToml {
    #[serde(default)]
    pub rules: RuleConfig,
    #[serde(default)]
    pub preferences: Preferences,
    #[serde(default)]
    pub commands: HashMap<String, CommandEntry>,
}
#[derive(Debug, Clone, Default)]
pub struct Config {
    pub include_patterns: Vec<regex::Regex>,
    pub exclude_patterns: Vec<regex::Regex>,
    pub code_only: bool,
    pub verbose: bool,
    pub rules: RuleConfig,
    pub preferences: Preferences,
    pub commands: HashMap<String, Vec<String>>,
}


// ======================================================
// src/detection.rs
// ======================================================
#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum BuildSystemType {
    Rust,
    Node,
    Python,
    Go,
    CMake,
    Conan,
}
impl fmt::Display for BuildSystemType { ... }
#[derive(Default)]
pub struct Detector;
impl Detector { ... }


// ======================================================
// src/analysis/scope.rs  [MID]
// ======================================================
/// Represents a cohesion and coupling scope (Class, Struct+Impl, Enum).
#[derive(Debug, Clone, Serialize)]
pub struct Scope {
    name: String,
    row: usize,
    is_enum: bool,
    fields: HashMap<String, FieldInfo>,
    methods: HashMap<String, Method>,
    derives: HashSet<String>,
}
#[derive(Debug, Clone, Serialize)]
pub struct FieldInfo {
    pub name: String,
    pub is_public: bool,
}
impl FieldInfo { ... }
/// Represents a method within a scope.
#[derive(Debug, Clone, Serialize)]
pub struct Method {
    pub name: String,
    /// Fields accessed by this method
    pub field_access: HashSet<String>,
    /// Other methods in the same scope called by this method (Cohesion)
    pub internal_calls: HashSet<String>,
    /// Calls to things outside this scope (Coupling/SFOUT)
    pub external_calls: HashSet<String>,
    /// Human-understandability score
    pub cognitive_complexity: usize,
    /// Does the method mutate state? (&mut self)
    pub is_mutable: bool,
}
impl Method { ... }
impl Scope { ... }


// ======================================================
// src/mutate/runner.rs
// ======================================================
/// Result of testing a single mutation.
#[derive(Debug, Clone)]
pub struct MutationResult {
    pub point: MutationPoint,
    pub survived: bool,
    pub duration_ms: u64,
}
/// Configuration for the mutation runner.
#[derive(Debug, Clone)]
pub struct RunnerConfig {
    pub test_command: String,
    pub test_args: Vec<String>,
    pub timeout_secs: u64,
    pub workers: usize,
}
impl Default for RunnerConfig { ... }
impl RunnerConfig { ... }
/// Runs all mutations and collects results.
///
/// NOTE: Mutations run serially because parallel execution requires
/// separate workspace copies. This is a v1 limitation.
///
/// # Errors
/// Returns error if file operations fail.
pub fn run_mutations(
    points: &[MutationPoint],
    config: &RunnerConfig,
    workdir: &Path,
    on_progress: impl Fn(usize, usize, &MutationResult) + Sync,
) -> Result<Vec<MutationResult>> { ... }
pub fn summarize(results: &[MutationResult]) -> MutationSummary { ... }
/// Summary statistics for a mutation run.
#[derive(Debug, Clone)]
pub struct MutationSummary {
    pub total: usize,
    pub killed: usize,
    pub survived: usize,
    pub score: f64,
    pub total_duration_ms: u64,
}


// ======================================================
// src/error.rs
// ======================================================
pub type SlopChopError = anyhow::Error;


// ======================================================
// src/tokens.rs  [LOW]
// ======================================================
pub struct Tokenizer;
impl Tokenizer { ... }


// ======================================================
// src/graph/locality/types.rs  [LOW]
// ======================================================
/// Coupling metrics for a single file node.
#[derive(Debug, Clone, Default)]
pub struct Coupling {
    /// Afferent coupling (fan-in): files that depend ON this file.
    afferent: usize,
    /// Efferent coupling (fan-out): files this file depends ON.
    efferent: usize,
}
impl Coupling { ... }
/// Classification of a node's role in the dependency topology.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum NodeIdentity {
    StableHub,
    VolatileLeaf,
    IsolatedDeadwood,
    GodModule,
    Standard,
}
impl NodeIdentity { ... }
/// A dependency edge with computed locality metrics.
#[derive(Debug, Clone)]
pub struct LocalityEdge {
    pub from: PathBuf,
    pub to: PathBuf,
    pub distance: usize,
    pub target_skew: f64,
    pub target_identity: NodeIdentity,
}
impl LocalityEdge { ... }
/// Result of validating a single edge.
#[derive(Debug, Clone)]
pub enum EdgeVerdict {
    Pass { reason: PassReason },
    Fail { edge: LocalityEdge, suggestion: String },
}
/// Reason an edge passed validation.
#[derive(Debug, Clone, Copy)]
pub enum PassReason {
    L1Cache,
    WithinDistance,
    VerticalRouting,
    Exempted,
}


// ======================================================
// src/clean.rs
// ======================================================
/// Runs the clean command: removes context.txt and ensures gitignore.
///
/// # Errors
/// Returns error if file operations or git commands fail.
pub fn run(commit: bool) -> Result<()> { ... }


// ======================================================
// src/analysis/patterns/concurrency_sync.rs  [LOW]
// ======================================================
/// C04: Arc<Mutex<T>> without documentation
#[must_use]
pub fn detect_c04(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/graph/rank/queries.rs  [LOW]
// ======================================================
#[must_use]
pub fn get_neighbors(graph: &RepoGraph, anchor: &Path) -> Vec<PathBuf> { ... }
#[must_use]
pub fn get_ranked_files(graph: &RepoGraph) -> Vec<(PathBuf, f64)> { ... }
#[must_use]
pub fn get_dependencies(graph: &RepoGraph, anchor: &Path) -> Vec<PathBuf> { ... }
#[must_use]
pub fn get_dependents(graph: &RepoGraph, anchor: &Path) -> Vec<PathBuf> { ... }
#[must_use]
pub fn get_graph_tags(graph: &RepoGraph) -> Vec<Tag> { ... }
pub fn collect_dependents(
    def_map: &HashMap<String, HashSet<PathBuf>>,
    ref_map: &HashMap<String, HashSet<PathBuf>>,
    anchor: &PathBuf,
    result: &mut HashSet<PathBuf>,
) { ... }
pub fn collect_dependencies(
    def_map: &HashMap<String, HashSet<PathBuf>>,
    ref_map: &HashMap<String, HashSet<PathBuf>>,
    anchor: &PathBuf,
    result: &mut HashSet<PathBuf>,
) { ... }


// ======================================================
// src/signatures/ordering.rs  [LOW]
// ======================================================
/// Computes topological order: files with no dependencies first.
///
/// Falls back to `PageRank` order for cycles or disconnected nodes.
#[must_use]
pub fn topological_order(graph: &RepoGraph, all_files: &[PathBuf]) -> Vec<PathBuf> { ... }


// ======================================================
// src/spinner/render.rs  [LOW]
// ======================================================
impl SimpleColor for str { ... }
pub fn run_hud_loop(running: &Arc<AtomicBool>, hud: &SafeHud) { ... }


// ======================================================
// src/spinner/client.rs  [LOW]
// ======================================================
/// Handles updates to the HUD state.
#[derive(Clone)]
pub struct SpinnerClient {
    state: SafeHud,
}
impl SpinnerClient { ... }


// ======================================================
// src/discovery.rs  [LOW]
// ======================================================
/// Runs the file discovery pipeline.
///
/// # Errors
/// Returns error if regexes are invalid or file system walk fails.
pub fn discover(config: &Config) -> Result<Vec<PathBuf>> { ... }
/// Groups files by their parent directory.
#[must_use]
pub fn group_by_directory(files: &[PathBuf]) -> HashMap<PathBuf, Vec<PathBuf>> { ... }


// ======================================================
// src/graph/locality/layers.rs  [LOW]
// ======================================================
/// Infers layers from a set of edges.
/// Returns a map of Path -> Layer Index.
pub fn infer_layers<'a, I>(edges: I) -> HashMap<PathBuf, usize>
where
    I: Iterator<Item = (&'a Path, &'a Path)> + Clone,
{ ... }
pub fn check_layer_violation(
    edge: &LocalityEdge,
    layers: &HashMap<PathBuf, usize>,
) -> Option<ViolationKind> { ... }


// ======================================================
// src/lang.rs  [HIGH]
// ======================================================
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Lang {
    Rust,
    Python,
    TypeScript,
}
#[derive(Debug, Clone, Copy)]
pub enum QueryKind {
    Naming,
    Complexity,
    Imports,
    Defs,
    Exports,
    Skeleton,
}
impl Lang { ... }


// ======================================================
// src/analysis/aggregator.rs  [HIGH]
// ======================================================
/// Results extracted from a single file.
#[derive(Debug, Clone, Default, Serialize)]
pub struct FileAnalysis {
    pub path_str: String,
    pub scopes: HashMap<String, Scope>,
    pub violations: Vec<Violation>,
}
pub struct Aggregator {
    pub violations: HashMap<PathBuf, Vec<Violation>>,
    pub global_scopes: HashMap<String, Scope>,
    pub path_map: HashMap<String, PathBuf>,
}
impl Default for Aggregator { ... }
impl Aggregator { ... }


// ======================================================
// src/graph/locality/mod.rs  [HIGH]
// ======================================================
//! Law of Locality enforcement for topological integrity.
//!
//! Implements the Universal Locality Algorithm with smart exemptions
//! and deep analysis for actionable insights.

pub mod analysis;
pub mod classifier;
pub mod coupling;
pub mod cycles;
pub mod distance;
pub mod edges;
pub mod exemptions;
pub mod layers;
pub mod report;
pub mod types;
pub mod validator;


// ======================================================
// src/analysis/cognitive.rs  [HIGH]
// ======================================================
pub struct CognitiveAnalyzer;
impl CognitiveAnalyzer { ... }
impl<'a> Scorer<'a> { ... }


// ======================================================
// src/graph/locality/coupling.rs  [HIGH]
// ======================================================
/// Computes coupling metrics for all files in a dependency graph.
pub fn compute_coupling<'a, I>(edges: I) -> HashMap<PathBuf, Coupling>
where
    I: Iterator<Item = (&'a Path, &'a Path)>,
{ ... }


// ======================================================
// src/graph/locality/exemptions.rs  [HIGH]
// ======================================================
/// Checks if an edge is a structural Rust pattern that should be auto-exempted.
#[must_use]
pub fn is_structural_pattern(from: &Path, to: &Path) -> bool { ... }


// ======================================================
// src/graph/locality/cycles.rs  [HIGH]
// ======================================================
/// Detects cycles in a dependency graph.
/// Returns a list of cycles, where each cycle is a list of nodes involved.
pub fn detect_cycles<'a, I>(edges: I) -> Vec<Vec<PathBuf>>
where
    I: Iterator<Item = (&'a Path, &'a Path)>,
{ ... }


// ======================================================
// src/graph/locality/distance.rs  [HIGH]
// ======================================================
/// Computes D(a, b) = (depth(a) - depth(LCA)) + (depth(b) - depth(LCA)).
#[must_use]
pub fn compute_distance(from: &Path, to: &Path) -> usize { ... }
/// Returns the LCA path between two files.
#[must_use]
pub fn find_lca(from: &Path, to: &Path) -> PathBuf { ... }


// ======================================================
// src/analysis/checks/syntax.rs  [HIGH]
// ======================================================
/// Checks for syntax errors or missing nodes in the AST.
pub fn check_syntax(ctx: &CheckContext, out: &mut Vec<Violation>) { ... }


// ======================================================
// src/graph/tsconfig.rs  [HIGH]
// ======================================================
/// Resolved path mapping configuration from tsconfig.
#[derive(Debug, Default)]
pub struct TsConfig {
    pub base_url: Option<PathBuf>,
    pub paths: HashMap<String, Vec<PathBuf>>,
}
impl TsConfig { ... }


// ======================================================
// src/graph/defs/extract.rs  [HIGH]
// ======================================================
/// A symbol definition found in source code.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Definition {
    pub name: String,
    pub kind: DefKind,
    pub line: usize,
    pub signature: String,
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum DefKind {
    Function,
    Struct,
    Enum,
    Trait,
    Impl,
    Module,
    Constant,
    Class,
    Interface,
    Type,
}
/// Extracts all symbol definitions from source code.
#[must_use]
pub fn extract(path: &Path, content: &str) -> Vec<Definition> { ... }


// ======================================================
// src/graph/imports.rs  [HIGH]
// ======================================================
/// Extracts raw import strings from the given file content.
///
/// # Arguments
/// * `path` - File path (used for language detection).
/// * `content` - Source code.
///
/// # Returns
/// A list of imported module names/paths (e.g., "`std::io`", "./utils", "react").
#[must_use]
pub fn extract(path: &Path, content: &str) -> Vec<String> { ... }


// ======================================================
// src/skeleton.rs  [HIGH]
// ======================================================
/// Reduces code to its structural skeleton (signatures only).
///
/// # Arguments
/// * `path` - The file path (used for language detection).
/// * `content` - The full source code.
///
/// # Returns
/// The skeletonized code, or the original content if language is unsupported.
#[must_use]
pub fn clean(path: &Path, content: &str) -> String { ... }


// ======================================================
// src/analysis/patterns/idiomatic.rs  [HIGH]
// ======================================================
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/analysis/patterns/resource.rs  [HIGH]
// ======================================================
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/mutate/discovery.rs  [HIGH]
// ======================================================
/// Discovers all mutation points in a single file.
///
/// # Errors
/// Returns error if file cannot be read or parsed.
pub fn discover_mutations(path: &Path) -> Result<Vec<MutationPoint>> { ... }


// ======================================================
// src/analysis/patterns/semantic.rs  [HIGH]
// ======================================================
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/graph/rank/pagerank.rs  [HIGH]
// ======================================================
pub fn compute(
    edges: &HashMap<PathBuf, HashMap<PathBuf, usize>>,
    all_files: &HashSet<PathBuf>,
    anchor: Option<&PathBuf>,
) -> HashMap<PathBuf, f64> { ... }


// ======================================================
// src/graph/locality/classifier.rs  [HIGH]
// ======================================================
/// Configuration thresholds for node classification.
#[derive(Debug, Clone)]
pub struct ClassifierConfig {
    pub hub_threshold: f64,
    pub min_hub_afferent: usize,
    pub god_module_threshold: usize,
    pub deadwood_threshold: usize,
    pub volatile_leaf_efferent: usize,
}
impl Default for ClassifierConfig { ... }
/// Classifies a file based on its coupling metrics.
#[must_use]
pub fn classify(coupling: &Coupling, config: &ClassifierConfig) -> NodeIdentity { ... }


// ======================================================
// src/mutate/mutations.rs  [HIGH]
// ======================================================
/// A single mutation point discovered in the codebase.
#[derive(Debug, Clone)]
pub struct MutationPoint {
    pub file: PathBuf,
    pub line: usize,
    pub column: usize,
    pub byte_start: usize,
    pub byte_end: usize,
    pub original: String,
    pub mutated: String,
    pub kind: MutationKind,
}
/// Categories of mutations we can apply.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MutationKind {
    /// Comparison operators: == != < > <= >=
    Comparison,
    /// Logical operators: && ||
    Logical,
    /// Boolean literals: true false
    Boolean,
    /// Arithmetic operators: + - * /
    Arithmetic,
    /// Return value mutations
    ReturnValue,
}
impl MutationKind { ... }
/// Attempts to create a mutation for an operator or literal.
#[must_use]
pub fn get_mutation(text: &str) -> Option<(&'static str, MutationKind)> { ... }
/// Applies a mutation to source code, returning the mutated version.
#[must_use]
pub fn apply_mutation(source: &str, point: &MutationPoint) -> String { ... }


// ======================================================
// src/branch.rs  [HIGH]
// ======================================================
/// Counts modified files on the work branch.
#[must_use]
pub fn count_modified_files() -> usize { ... }
/// Creates or resets the work branch.
///
/// # Errors
/// Returns error if git commands fail.
pub fn init_branch(force: bool) -> Result<BranchResult> { ... }
/// Promotes work branch to main.
///
/// # Errors
/// Returns error if git commands fail or checks don't pass.
pub fn promote(dry_run: bool, custom_msg: Option<String>) -> Result<PromoteResult> { ... }
/// Aborts work branch and returns to main.
///
/// # Errors
/// Returns error if git commands fail.
pub fn abort() -> Result<()> { ... }
/// Returns the name of the work branch.
#[must_use]
pub fn work_branch_name() -> &'static str { ... }
/// Checks if we're currently on the work branch.
#[must_use]
pub fn on_work_branch() -> bool { ... }
#[derive(Debug)]
pub enum BranchResult {
    Created,
    Reset,
    AlreadyOnBranch,
}
#[derive(Debug)]
pub enum PromoteResult {
    Merged,
    DryRun,
}


// ======================================================
// src/analysis/patterns/logic.rs  [HIGH]
// ======================================================
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/config/mod.rs  [HIGH]
// ======================================================
pub mod io;
pub mod locality;
pub mod types;
impl Config { ... }
pub fn save_to_file(
    rules: &RuleConfig,
    prefs: &Preferences,
    commands: &std::collections::HashMap<String, Vec<String>>,
) -> Result<()> { ... }


// ======================================================
// src/types.rs  [MID]
// ======================================================
/// A single violation detected during analysis.
#[derive(Debug, Clone, Serialize)]
pub struct Violation {
    pub row: usize,
    pub message: String,
    pub law: &'static str,
    pub details: Option<ViolationDetails>,
}
/// Rich details for prescriptive violation reporting.
#[derive(Debug, Clone, Default, Serialize)]
pub struct ViolationDetails {
    pub function_name: Option<String>,
    pub analysis: Vec<String>,
    pub suggestion: Option<String>,
}
impl Violation { ... }
/// Analysis results for a single file.
#[derive(Debug, Clone, Serialize)]
pub struct FileReport {
    pub path: PathBuf,
    pub token_count: usize,
    pub complexity_score: usize,
    pub violations: Vec<Violation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis: Option<FileAnalysis>,
}
impl FileReport { ... }
/// Aggregated results from scanning multiple files.
#[derive(Debug, Clone, Default, Serialize)]
pub struct ScanReport {
    pub files: Vec<FileReport>,
    pub total_tokens: usize,
    pub total_violations: usize,
    pub duration_ms: u128,
}
impl ScanReport { ... }
/// Result of an external command execution.
#[derive(Debug, Clone, Serialize)]
pub struct CommandResult {
    pub command: String,
    pub exit_code: i32,
    pub stdout: String,
    pub stderr: String,
    pub duration_ms: u64,
}
/// Aggregated results for a full check run.
#[derive(Debug, Clone, Serialize)]
pub struct CheckReport {
    pub scan: ScanReport,
    pub commands: Vec<CommandResult>,
    pub passed: bool,
}


// ======================================================
// src/analysis/types.rs  [MID]
// ======================================================
/// A single violation detected during analysis.
#[derive(Debug, Clone, Serialize)]
pub struct Violation {
    pub row: usize,
    pub message: String,
    pub law: &'static str,
    pub details: Option<ViolationDetails>,
}
#[derive(Debug, Clone, Default, Serialize)]
pub struct ViolationDetails {
    pub function_name: Option<String>,
    pub analysis: Vec<String>,
    pub suggestion: Option<String>,
}
impl Violation { ... }
#[derive(Debug, Clone, Serialize)]
pub struct FileReport {
    pub path: PathBuf,
    pub token_count: usize,
    pub complexity_score: usize,
    pub violations: Vec<Violation>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub analysis: Option<FileAnalysis>,
}
impl FileReport { ... }
#[derive(Debug, Clone, Default, Serialize)]
pub struct ScanReport {
    pub files: Vec<FileReport>,
    pub total_tokens: usize,
    pub total_violations: usize,
    pub duration_ms: u128,
}
impl ScanReport { ... }
#[derive(Debug, Clone, Serialize)]
pub struct CommandResult {
    pub command: String,
    pub exit_code: i32,
    pub stdout: String,
    pub stderr: String,
    pub duration_ms: u64,
}
#[derive(Debug, Clone, Serialize)]
pub struct CheckReport {
    pub scan: ScanReport,
    pub commands: Vec<CommandResult>,
    pub passed: bool,
}


// ======================================================
// src/analysis/patterns/mod.rs  [MID]
// ======================================================
//! AST pattern detection for violations.

pub mod state;
pub mod concurrency;
pub mod concurrency_lock;
pub mod concurrency_sync;
pub mod performance;
pub mod security;
pub mod semantic;
pub mod resource;
pub mod db_patterns;
pub mod idiomatic;
pub mod logic;
/// Runs all pattern detections on a file.
#[must_use]
pub fn detect_all(path: &Path, source: &str) -> Vec<Violation> { ... }
/// Helper to get a node from a capture by index.
/// Centralized to reduce duplication and fix lifetime issues.
#[must_use]
pub fn get_capture_node<'a>(
    m: &tree_sitter::QueryMatch<'_, 'a>,
    idx: Option<u32>,
) -> Option<tree_sitter::Node<'a>> { ... }


// ======================================================
// src/graph/mod.rs  [MID]
// ======================================================
pub mod defs;
pub mod imports;
pub mod locality;
pub mod rank;
pub mod resolver;
pub mod tsconfig;


// ======================================================
// src/analysis/checks.rs  [MID]
// ======================================================
/// Context for running checks on a single file.
pub struct CheckContext<'a> {
    pub root: Node<'a>,
    pub source: &'a str,
    pub filename: &'a str,
    pub config: &'a RuleConfig,
}


// ======================================================
// src/lib.rs  [MID]
// ======================================================
pub mod analysis;
pub mod branch;
pub mod clean;
pub mod cli;
pub mod config;
pub mod constants;
pub mod detection;
pub mod discovery;
pub mod error;
pub mod events;
pub mod exit;
pub mod graph;
pub mod lang;
pub mod mutate;
pub mod project;
pub mod reporting;
pub mod signatures;
pub mod skeleton;
pub mod spinner;
pub mod tokens;
pub mod types;
pub mod utils;
pub mod verification;


// ======================================================
// src/cli/mod.rs  [MID]
// ======================================================
//! CLI command handlers.

pub mod args;
pub mod config_ui;
pub mod dispatch;
pub mod git_ops;
pub mod handlers;
pub mod locality;
pub mod mutate_handler;


// ======================================================
// src/spinner/mod.rs  [LOW]
// ======================================================
//! Triptych HUD (Head-Up Display) for process execution feedback.

pub mod client;
pub mod controller;
pub mod render;
pub mod safe_hud;
pub mod state;
/// Starts the spinner and returns the client (for updates) and controller (for lifecycle).
///
/// This split ensures high cohesion: the client is passed to workers, while the
/// controller is held by the main thread to manage the spinner's lifetime.
#[must_use]
pub fn start(title: impl Into<String>) -> (SpinnerClient, SpinnerController) { ... }


// ======================================================
// src/graph/locality/validator.rs  [LOW]
// ======================================================
/// Configuration for locality validation.
#[derive(Debug, Clone)]
pub struct ValidatorConfig {
    pub max_distance: usize,
    pub l1_threshold: usize,
    pub classifier: ClassifierConfig,
    pub exempt_patterns: Vec<String>,
}
impl Default for ValidatorConfig { ... }
/// Result of validating all edges.
#[derive(Debug, Default)]
pub struct ValidationReport {
    passed: Vec<LocalityEdge>,
    failed: Vec<LocalityEdge>,
    cycles: Vec<Vec<PathBuf>>,
    layers: std::collections::HashMap<PathBuf, usize>,
    total_edges: usize,
    entropy: f64,
}
impl ValidationReport { ... }
pub fn validate_edge(
    from: &Path,
    to: &Path,
    target_coupling: &Coupling,
    layers: &std::collections::HashMap<PathBuf, usize>,
    config: &ValidatorConfig,
) -> EdgeVerdict { ... }
/// Validates all edges in a dependency graph.
pub fn validate_graph<'a, I>(edges: I, config: &ValidatorConfig) -> ValidationReport
where
    I: Iterator<Item = (&'a Path, &'a Path)> + Clone,
{ ... }


// ======================================================
// src/cli/config_ui/mod.rs  [LOW]
// ======================================================
pub mod editor;
pub mod items;
pub mod logic;
pub mod render;


// ======================================================
// src/cli/config_ui/editor.rs  [LOW]
// ======================================================
pub struct ConfigEditor {
    config: Config,
    selected: usize,
    items: Vec<ConfigItem>,
    modified: bool,
}
#[derive(Debug, Clone)]
pub enum EventResult {
    Continue,
    Exit,
    Save(Box<Config>),
}
#[derive(Debug, Clone)]
pub enum EditResult {
    Continue,
    Commit(usize),
    Cancel,
}
impl ConfigEditor { ... }
/// Entry point for the config command
///
/// # Errors
/// Returns error if loading config, running editor, or saving config fails.
pub fn run_config_editor() -> Result<()> { ... }


// ======================================================
// src/mutate/mod.rs  [LOW]
// ======================================================
//! Cross-language mutation testing [EXPERIMENTAL].
//!
//! This module provides mutation testing capabilities across Rust, TypeScript,
//! and Python codebases. It discovers mutable points in source code, applies
//! mutations, runs tests, and reports which mutations survive (test gaps).
//!
//! # Architecture
//!
//! - `discovery`: Finds mutation points using tree-sitter AST analysis
//! - `mutations`: Defines mutation types and application logic
//! - `runner`: Executes tests against mutated code (serial, v1)
//! - `report`: Formats results for terminal and JSON output
//!
//! # Example
//!
//! ```ignore
//! slopchop mutate --filter src/tokens.rs --timeout 30
//! ```

pub mod discovery;
pub mod mutations;
pub mod report;
pub mod runner;
/// Options for mutation testing.
#[derive(Debug, Clone)]
pub struct MutateOptions {
    pub workers: Option<usize>,
    pub timeout_secs: u64,
    pub json: bool,
    pub filter: Option<String>,
}
impl Default for MutateOptions { ... }
/// Result of a mutation testing run.
#[derive(Debug)]
pub struct MutateReport {
    pub summary: MutationSummary,
    pub results: Vec<runner::MutationResult>,
}
/// Runs mutation testing on the codebase.
///
/// # Errors
/// Returns error if discovery or test execution fails.
pub fn run(workdir: &Path, opts: &MutateOptions) -> Result<MutateReport> { ... }


// ======================================================
// src/analysis/mod.rs  [LOW]
// ======================================================
//! Core analysis logic (The "Rule Engine").

pub mod ast;
pub mod checks;
pub mod cognitive;
pub mod metrics;
pub mod safety;
pub mod structural;
pub mod scope;
pub mod inspector;
pub mod aggregator;
pub mod deep;
pub mod visitor;
pub mod extract;
pub mod extract_impl;
pub mod patterns;
pub mod worker;


// ======================================================
// src/cli/config_ui/items.rs  [LOW]
// ======================================================
/// Configuration items that can be edited
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ConfigItem {
    MaxTokens,
    MaxComplexity,
    MaxNesting,
    MaxArgs,
    MaxWords,
    MaxLcom4,
    MinAhf,
    MaxCbo,
    MaxSfout,
    AutoCopy,
    WriteFixPacket,
    RequirePlan,
    AutoPromote,
    LocalityMode,
    LocalityMaxDistance,
}
impl ConfigItem { ... }


// ======================================================
// src/verification/mod.rs  [LOW]
// ======================================================
/// Result of running the verification pipeline.
#[derive(Debug)]
pub struct VerificationReport {
    /// Whether all commands passed.
    pub passed: bool,
    /// Combined output from all commands.
    pub output: String,
}
impl VerificationReport { ... }
/// Runs the verification pipeline using commands from config.
pub fn run(repo_root: &Path) -> VerificationReport { ... }


// ======================================================
// src/spinner/handle.rs  [LOW]
// ======================================================
/// Handle for controlling the spinner thread.
pub struct SpinnerHandle {
    handle: thread::JoinHandle<()>,
    running: Arc<AtomicBool>,
}
impl SpinnerHandle { ... }


// ======================================================
// src/analysis/checks/banned.rs  [LOW]
// ======================================================
/// Checks for banned constructs (`.unwrap()` and `.expect()` calls).
pub fn check_banned(ctx: &CheckContext, banned_query: &Query, out: &mut Vec<Violation>) { ... }


// ======================================================
// src/analysis/checks/naming.rs  [LOW]
// ======================================================
/// Checks for naming violations (function name word count).
pub fn check_naming(ctx: &CheckContext, query: &Query, out: &mut Vec<Violation>) { ... }


// ======================================================
// src/analysis/checks/complexity.rs  [LOW]
// ======================================================
/// Checks for complexity metrics (arity, depth).
/// Note: Cognitive Complexity is calculated in `ast.rs` using the `cognitive` module.
/// This module focuses on Arity and Nesting Depth.
pub fn check_metrics(
    ctx: &CheckContext,
    func_query: &Query,
    _complexity_query: &Query, // Unused now
    out: &mut Vec<Violation>,
) -> usize { ... }


// ======================================================
// src/graph/rank/mod.rs  [LOW]
// ======================================================
pub mod builder;
pub mod graph;
pub mod pagerank;
pub mod tags;
pub mod queries;
/// Orchestrates graph construction and ranking.
pub struct GraphEngine;
impl GraphEngine { ... }


// ======================================================
// src/analysis/engine.rs  [LOW]
// ======================================================
/// Source files below this threshold skip structural metrics (LCOM4, CBO, AHF, SFOUT).
/// Rationale: For small projects, modularity metrics are noise, not signal.
pub const SMALL_CODEBASE_THRESHOLD: usize = 10;
/// The main analysis engine.
/// Orchestrates file scanning, pattern detection, and structural analysis.
pub struct Engine {
    config: Config,
}
impl Engine { ... }


// ======================================================
// src/analysis/extract_impl.rs  [LOW]
// ======================================================
pub fn extract(source: &str, root: Node, out: &mut HashMap<String, Scope>) { ... }


// ======================================================
// src/graph/defs/queries.rs  [LOW]
// ======================================================
pub struct DefExtractor;
impl DefExtractor { ... }


// ======================================================
// src/spinner/controller.rs  [LOW]
// ======================================================
/// Manages the spinner background thread.
pub struct SpinnerController {
    handle: Option<SpinnerHandle>,
    state: SafeHud,
}
impl SpinnerController { ... }


// ======================================================
// src/graph/locality/analysis/mod.rs  [LOW]
// ======================================================
//! Deep topology analysis: categorize violations, find patterns, suggest fixes.

pub mod metrics;
pub mod violations;
/// Analysis results with insights.
#[derive(Debug, Default)]
pub struct TopologyAnalysis {
    pub violations: Vec<CategorizedViolation>,
    pub god_modules: Vec<GodModuleInfo>,
    pub hub_candidates: Vec<HubCandidate>,
    pub module_coupling: Vec<(String, String, usize)>,
}
#[must_use]
pub fn analyze(
    report: &ValidationReport,
    couplings: &HashMap<PathBuf, Coupling>,
) -> TopologyAnalysis { ... }


// ======================================================
// src/cli/handlers/mod.rs  [LOW]
// ======================================================
pub mod scan_report;
#[must_use]
pub fn get_repo_root() -> PathBuf { ... }
/// Handles the scan command.
///
/// # Errors
/// Returns error if scan execution fails.
pub fn handle_scan(verbose: bool, locality: bool, json: bool) -> Result<SlopChopExit> { ... }
/// Handles the check command.
///
/// # Errors
/// Returns error if report file cannot be written.
pub fn handle_check(json: bool) -> Result<SlopChopExit> { ... }
/// Handles the signatures command.
///
/// # Errors
/// Returns error if signature generation fails.
pub fn handle_signatures(opts: SignatureOptions) -> Result<SlopChopExit> { ... }


// ======================================================
// src/signatures/mod.rs  [LOW]
// ======================================================
#[derive(Debug, Clone, Copy)]
pub struct SignatureOptions {
    pub copy: bool,
    pub stdout: bool,
}
/// Generates a graph-aware type-surface signature map.
///
/// # Errors
/// Returns error if file discovery or reading fails.
pub fn run(opts: &SignatureOptions) -> Result<()> { ... }


// ======================================================
// src/analysis/deep.rs  [LOW]
// ======================================================
pub struct DeepAnalyzer<'a> {
    config: &'a RuleConfig,
}
impl<'a> DeepAnalyzer<'a> { ... }


// ======================================================
// src/analysis/inspector.rs  [LOW]
// ======================================================
pub struct Inspector<'a> {
    config: &'a RuleConfig,
}
impl<'a> Inspector<'a> { ... }


// ======================================================
// src/analysis/visitor.rs  [LOW]
// ======================================================
pub struct AstVisitor<'a> {
    source: &'a str,
    lang: Lang,
}
impl<'a> AstVisitor<'a> { ... }


// ======================================================
// src/graph/locality/report.rs  [LOW]
// ======================================================
/// Prints a comprehensive locality report.
pub fn print_full_report(report: &ValidationReport, analysis: &TopologyAnalysis) { ... }


// ======================================================
// src/analysis/ast.rs  [LOW]
// ======================================================
pub struct Analyzer;
impl Default for Analyzer { ... }
pub struct AnalysisResult {
    pub violations: Vec<Violation>,
    pub max_complexity: usize,
}
impl Analyzer { ... }


// ======================================================
// src/graph/rank/builder.rs  [LOW]
// ======================================================
/// Container for the raw data needed to construct the graph.
pub struct GraphData {
    pub tags: Vec<Tag>,
    pub defines: HashMap<String, HashSet<PathBuf>>,
    pub references: HashMap<String, HashSet<PathBuf>>,
    pub edges: HashMap<PathBuf, HashMap<PathBuf, usize>>,
    pub all_files: HashSet<PathBuf>,
}
/// Extracts tags from all files and builds the initial edge set.
#[must_use]
pub fn build_data(files: &[(PathBuf, String)]) -> GraphData { ... }
pub fn rebuild_topology(
    defines: &HashMap<String, HashSet<PathBuf>>,
    references: &HashMap<String, HashSet<PathBuf>>,
) -> (HashMap<PathBuf, HashMap<PathBuf, usize>>, HashSet<PathBuf>) { ... }


// ======================================================
// src/graph/resolver.rs  [LOW]
// ======================================================
/// Resolves an import string to a likely file path on disk.
#[must_use]
pub fn resolve(project_root: &Path, current_file: &Path, import_str: &str) -> Option<PathBuf> { ... }


// ======================================================
// src/graph/locality/edges.rs  [LOW]
// ======================================================
/// Collects all dependency edges from the given source files.
///
/// # Arguments
/// * `root` - Project root directory
/// * `files` - Source files to analyze
///
/// # Returns
/// Vec of (from, to) edges with paths relative to root.
///
/// # Errors
/// Returns error if file reading fails.
pub fn collect(root: &Path, files: &[PathBuf]) -> Result<Vec<(PathBuf, PathBuf)>> { ... }


// ======================================================
// src/graph/locality/analysis/metrics.rs  [LOW]
// ======================================================
#[derive(Debug, Clone)]
pub struct GodModuleInfo {
    pub path: PathBuf,
    pub outbound_violations: usize,
    pub targets: Vec<PathBuf>,
}
#[derive(Debug, Clone)]
pub struct HubCandidate {
    pub path: PathBuf,
    pub fan_in: usize,
    pub importers: Vec<PathBuf>,
}
#[must_use]
pub fn find_god_modules(violations: &[CategorizedViolation]) -> Vec<GodModuleInfo> { ... }
pub fn find_hub_candidates(
    couplings: &HashMap<PathBuf, Coupling>,
    report: &ValidationReport,
) -> Vec<HubCandidate> { ... }
#[must_use]
pub fn compute_module_coupling(edges: &[LocalityEdge]) -> Vec<(String, String, usize)> { ... }


// ======================================================
// src/cli/handlers/scan_report.rs  [LOW]
// ======================================================
/// Prints a formatted scan report to stdout.
pub fn print(report: &ScanReport) { ... }
/// Aggregates violations by law type for summary display.
#[must_use]
pub fn aggregate_by_law(report: &ScanReport) -> HashMap<&'static str, usize> { ... }


// ======================================================
// src/cli/locality.rs  [LOW]
// ======================================================
/// Result of a locality check for use in verification pipeline.
pub struct LocalityResult {
    pub passed: bool,
    pub violations: usize,
}
/// Runs locality validation on the codebase.
///
/// # Errors
/// Returns error if file discovery or import extraction fails.
pub fn handle_locality() -> Result<SlopChopExit> { ... }
/// Runs locality check and returns result. Used by verification pipeline.
///
/// # Errors
/// Returns error if file discovery or graph construction fails.
pub fn run_locality_check(cwd: &Path) -> Result<LocalityResult> { ... }
/// Runs locality check silently, returning only pass/fail. For pipeline use.
///
/// # Errors
/// Returns error if file discovery or graph construction fails.
pub fn check_locality_silent(cwd: &Path) -> Result<(bool, usize)> { ... }
/// Returns whether locality is in error mode (blocking).
#[must_use]
pub fn is_locality_blocking() -> bool { ... }


// ======================================================
// src/cli/dispatch.rs  [LOW]
// ======================================================
/// Executes the parsed command.
///
/// # Errors
/// Returns error if the command handler fails.
pub fn execute(command: Commands) -> Result<SlopChopExit> { ... }


// ======================================================
// src/cli/mutate_handler.rs  [LOW]
// ======================================================
/// Handles the mutate command.
///
/// # Errors
/// Returns error if mutation testing fails.
pub fn handle_mutate(
    workers: Option<usize>,
    timeout: u64,
    json: bool,
    filter: Option<String>,
) -> Result<SlopChopExit> { ... }


// ======================================================
// src/cli/config_ui/render.rs  [LOW]
// ======================================================
/// Renders the configuration UI
///
/// # Errors
/// Returns error if terminal manipulation fails.
pub fn draw(items: &[ConfigItem], selected: usize, config: &Config) -> Result<()> { ... }


// ======================================================
// src/cli/config_ui/logic.rs  [LOW]
// ======================================================
/// Runs the editor event loop.
///
/// # Errors
/// Returns error if terminal setup or event reading fails.
pub fn run_editor(editor: &mut ConfigEditor) -> Result<Option<Config>> { ... }
pub fn move_selection(editor: &mut ConfigEditor, delta: isize) { ... }


// ======================================================
// src/verification/runner.rs  [LOW]
// ======================================================
/// Runs a list of commands and captures combined output.
#[must_use]
pub fn run_commands(repo_root: &Path, commands: &[String]) -> VerificationReport { ... }


// ======================================================
// src/analysis/safety.rs  [LOW]
// ======================================================
/// Checks for unsafe blocks and ensures they have justification comments.
pub fn check_safety(ctx: &checks::CheckContext, _query: &Query, out: &mut Vec<Violation>) { ... }


// ======================================================
// src/analysis/worker.rs  [LOW]
// ======================================================
#[must_use]
pub fn scan_file(path: &Path, config: &Config) -> FileReport { ... }
#[must_use]
pub fn is_ignored(path: &Path, patterns: &[String]) -> bool { ... }


// ======================================================
// src/analysis/patterns/concurrency.rs  [LOW]
// ======================================================
/// Detects concurrency-related violations in Rust code.
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/analysis/patterns/performance.rs  [LOW]
// ======================================================
#[must_use]
pub fn detect(source: &str, root: Node, path: &Path) -> Vec<Violation> { ... }


// ======================================================
// src/analysis/patterns/state.rs  [LOW]
// ======================================================
/// Detects state-related violations in Rust code.
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/analysis/patterns/db_patterns.rs  [LOW]
// ======================================================
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


// ======================================================
// src/analysis/patterns/security.rs  [LOW]
// ======================================================
#[must_use]
pub fn detect(source: &str, root: Node) -> Vec<Violation> { ... }


