# SlopChop v1.3.4 Technical Specification

**Document Type:** Implementation Specification  
**Created:** 2026-01-03  
**Status:** Ready for implementation  
**Estimated Effort:** 4-6 hours

---

## Executive Summary

v1.3.4 is a UX polish release with two features:

1. **Fix paste-back packet** - Restore auto-copy of AI feedback to clipboard when verification fails
2. **`slopchop config`** - Minimal interactive configuration editor

Both features existed in some form previously but were lost during the v1.3.0 consolidation that deleted the TUI.

---

## Feature 1: Fix Paste-Back Packet

### Problem

When `slopchop apply -c` runs verification and it fails, the AI feedback message is printed to stdout but NOT copied to clipboard. The user must manually select and copy the text.

The code path exists (`src/apply/messages.rs:264`) but it's only called for `ValidationFailure` outcomes, not for verification failures that happen in `executor.rs`.

### Root Cause Analysis

Looking at the current flow:

```
apply -c
  → processor::process_input()
    → executor::apply_to_stage_transaction()
      → verification::run_verification()  // Returns Result<bool>
        → If fails, prints errors directly
        → Does NOT generate AI feedback packet
        → Does NOT copy to clipboard
```

The `ValidationFailure` outcome with `ai_message` is only used for manifest/parser validation, not for verification failures (cargo clippy, cargo test, slopchop scan).

### Solution

#### Option A: Generate AI Feedback on Verification Failure (Recommended)

When verification fails, generate a structured AI feedback packet containing:
1. Which commands failed
2. The error output (truncated if huge)
3. The files that were modified (for context)

Then copy this to clipboard automatically.

#### Implementation

**File: `src/apply/verification.rs`**

Add a function to generate AI feedback:

```rust
pub fn generate_ai_feedback(
    failed_commands: &[(String, String)],  // (command, stderr)
    modified_files: &[String],
) -> String {
    let mut msg = String::from("VERIFICATION FAILED\n\n");
    
    msg.push_str("The following checks failed:\n\n");
    for (cmd, stderr) in failed_commands {
        msg.push_str(&format!("COMMAND: {cmd}\n"));
        msg.push_str("OUTPUT:\n");
        // Truncate to ~500 chars to avoid clipboard bloat
        let truncated = if stderr.len() > 500 {
            format!("{}...\n[truncated]", &stderr[..500])
        } else {
            stderr.clone()
        };
        msg.push_str(&truncated);
        msg.push_str("\n\n");
    }
    
    if !modified_files.is_empty() {
        msg.push_str("FILES MODIFIED IN THIS APPLY:\n");
        for f in modified_files {
            msg.push_str(&format!("- {f}\n"));
        }
    }
    
    msg.push_str("\nPlease fix the issues and provide corrected files.");
    msg
}
```

**File: `src/apply/executor.rs`**

In the verification flow, when checks fail:

```rust
// After verification fails
let ai_msg = verification::generate_ai_feedback(&failed, &touched_files);
crate::apply::messages::print_ai_feedback(&ai_msg);
// print_ai_feedback already calls copy_to_clipboard internally
```

**File: `src/apply/messages.rs`**

The `print_ai_feedback` function already copies to clipboard (line 264). Just ensure it's called.

### Testing

1. Create a file with a syntax error
2. Run `slopchop apply -c` 
3. Verify clipboard contains the AI feedback packet
4. Paste into AI, confirm it has enough context to fix

### Acceptance Criteria

- [ ] Verification failures auto-copy AI feedback to clipboard
- [ ] Feedback includes command name, truncated output, modified files
- [ ] Works on Windows, macOS, Linux
- [ ] No regression to existing `ValidationFailure` handling

---

## Feature 2: `slopchop config` Command

### Problem

After deleting the bloated TUI dashboard in v1.3.0, there's no interactive way to configure SlopChop. Users must:
1. Know the config file location (`slopchop.toml`)
2. Know the schema
3. Edit TOML manually

### Solution

A minimal interactive config editor that:
- Uses `crossterm` directly (already a dependency)
- No `ratatui` (we removed it as bloat)
- ~200 lines of code
- Arrow keys to navigate, Enter to toggle/edit, Esc to cancel

### UI Design

```
┌─ SlopChop Configuration ──────────────────┐
│                                           │
│  Rules                                    │
│  ├─ Max file tokens    [2000]             │
│  ├─ Max complexity     [8]                │
│  ├─ Max nesting        [3]                │
│  └─ Max args           [5]                │
│                                           │
│  Preferences                              │
│  ├─ [x] Auto-copy to clipboard            │
│  ├─ [ ] Write fix packet to file          │
│  ├─ [x] Require PLAN block                │
│  └─ [ ] Auto-promote on green             │
│                                           │
│  Locality                                 │
│  ├─ Mode               [warn ▾]           │
│  └─ Max distance       [4]                │
│                                           │
│  [Save]  [Cancel]                         │
└───────────────────────────────────────────┘

Controls: ↑↓ Navigate | Enter Edit/Toggle | Esc Cancel | S Save
```

### Implementation

**New file: `src/cli/config_ui.rs`**

```rust
// src/cli/config_ui.rs
//! Minimal interactive configuration editor.
//!
//! Uses crossterm directly for input handling.
//! No ratatui dependency - just raw terminal manipulation.

use crate::config::{Config, Preferences, Rules, LocalityConfig};
use anyhow::Result;
use crossterm::{
    cursor,
    event::{self, Event, KeyCode, KeyEvent},
    execute,
    style::{Color, Print, SetForegroundColor, ResetColor},
    terminal::{self, Clear, ClearType},
};
use std::io::{stdout, Write};

/// Configuration items that can be edited
enum ConfigItem {
    MaxTokens,
    MaxComplexity,
    MaxNesting,
    MaxArgs,
    AutoCopy,
    WriteFixPacket,
    RequirePlan,
    AutoPromote,
    LocalityMode,
    LocalityMaxDistance,
}

impl ConfigItem {
    fn all() -> Vec<Self> {
        vec![
            Self::MaxTokens,
            Self::MaxComplexity,
            Self::MaxNesting,
            Self::MaxArgs,
            Self::AutoCopy,
            Self::WriteFixPacket,
            Self::RequirePlan,
            Self::AutoPromote,
            Self::LocalityMode,
            Self::LocalityMaxDistance,
        ]
    }
    
    fn is_boolean(&self) -> bool {
        matches!(
            self,
            Self::AutoCopy | Self::WriteFixPacket | Self::RequirePlan | Self::AutoPromote
        )
    }
    
    fn is_enum(&self) -> bool {
        matches!(self, Self::LocalityMode)
    }
}

pub struct ConfigEditor {
    config: Config,
    selected: usize,
    items: Vec<ConfigItem>,
    modified: bool,
}

impl ConfigEditor {
    pub fn new(config: Config) -> Self {
        Self {
            config,
            selected: 0,
            items: ConfigItem::all(),
            modified: false,
        }
    }
    
    pub fn run(&mut self) -> Result<Option<Config>> {
        terminal::enable_raw_mode()?;
        let result = self.event_loop();
        terminal::disable_raw_mode()?;
        result
    }
    
    fn event_loop(&mut self) -> Result<Option<Config>> {
        loop {
            self.render()?;
            
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Up => {
                        if self.selected > 0 {
                            self.selected -= 1;
                        }
                    }
                    KeyCode::Down => {
                        if self.selected < self.items.len() - 1 {
                            self.selected += 1;
                        }
                    }
                    KeyCode::Enter => {
                        self.edit_current()?;
                    }
                    KeyCode::Char('s') | KeyCode::Char('S') => {
                        return Ok(Some(self.config.clone()));
                    }
                    KeyCode::Esc | KeyCode::Char('q') => {
                        return Ok(None);
                    }
                    _ => {}
                }
            }
        }
    }
    
    fn render(&self) -> Result<()> {
        let mut stdout = stdout();
        execute!(stdout, Clear(ClearType::All), cursor::MoveTo(0, 0))?;
        
        // Header
        execute!(
            stdout,
            SetForegroundColor(Color::Cyan),
            Print("┌─ SlopChop Configuration ──────────────────┐\n"),
            ResetColor
        )?;
        
        // Render each item
        for (i, item) in self.items.iter().enumerate() {
            let selected = i == self.selected;
            let prefix = if selected { "│ >" } else { "│  " };
            let value = self.get_value(item);
            let label = self.get_label(item);
            
            if selected {
                execute!(stdout, SetForegroundColor(Color::Yellow))?;
            }
            
            writeln!(stdout, "{prefix} {label:<25} {value}")?;
            
            if selected {
                execute!(stdout, ResetColor)?;
            }
        }
        
        // Footer
        execute!(
            stdout,
            Print("│                                           │\n"),
            Print("│  [S]ave  [Esc] Cancel                     │\n"),
            SetForegroundColor(Color::Cyan),
            Print("└───────────────────────────────────────────┘\n"),
            ResetColor
        )?;
        
        stdout.flush()?;
        Ok(())
    }
    
    fn get_label(&self, item: &ConfigItem) -> &'static str {
        match item {
            ConfigItem::MaxTokens => "Max file tokens",
            ConfigItem::MaxComplexity => "Max complexity",
            ConfigItem::MaxNesting => "Max nesting",
            ConfigItem::MaxArgs => "Max args",
            ConfigItem::AutoCopy => "Auto-copy to clipboard",
            ConfigItem::WriteFixPacket => "Write fix packet to file",
            ConfigItem::RequirePlan => "Require PLAN block",
            ConfigItem::AutoPromote => "Auto-promote on green",
            ConfigItem::LocalityMode => "Locality mode",
            ConfigItem::LocalityMaxDistance => "Locality max distance",
        }
    }
    
    fn get_value(&self, item: &ConfigItem) -> String {
        match item {
            ConfigItem::MaxTokens => format!("[{}]", self.config.rules.max_file_tokens),
            ConfigItem::MaxComplexity => format!("[{}]", self.config.rules.max_cyclomatic_complexity),
            ConfigItem::MaxNesting => format!("[{}]", self.config.rules.max_nesting_depth),
            ConfigItem::MaxArgs => format!("[{}]", self.config.rules.max_function_args),
            ConfigItem::AutoCopy => checkbox(self.config.preferences.auto_copy),
            ConfigItem::WriteFixPacket => checkbox(self.config.preferences.write_fix_packet),
            ConfigItem::RequirePlan => checkbox(self.config.preferences.require_plan),
            ConfigItem::AutoPromote => checkbox(self.config.preferences.auto_promote),
            ConfigItem::LocalityMode => format!("[{}]", self.config.rules.locality.mode),
            ConfigItem::LocalityMaxDistance => format!("[{}]", self.config.rules.locality.max_distance),
        }
    }
    
    fn edit_current(&mut self) -> Result<()> {
        let item = &self.items[self.selected];
        
        if item.is_boolean() {
            self.toggle_boolean(item);
            self.modified = true;
        } else if item.is_enum() {
            self.cycle_enum(item);
            self.modified = true;
        } else {
            // For numeric values, show inline editor
            if let Some(new_val) = self.edit_number(item)? {
                self.set_number(item, new_val);
                self.modified = true;
            }
        }
        
        Ok(())
    }
    
    fn toggle_boolean(&mut self, item: &ConfigItem) {
        match item {
            ConfigItem::AutoCopy => {
                self.config.preferences.auto_copy = !self.config.preferences.auto_copy;
            }
            ConfigItem::WriteFixPacket => {
                self.config.preferences.write_fix_packet = !self.config.preferences.write_fix_packet;
            }
            ConfigItem::RequirePlan => {
                self.config.preferences.require_plan = !self.config.preferences.require_plan;
            }
            ConfigItem::AutoPromote => {
                self.config.preferences.auto_promote = !self.config.preferences.auto_promote;
            }
            _ => {}
        }
    }
    
    fn cycle_enum(&mut self, item: &ConfigItem) {
        match item {
            ConfigItem::LocalityMode => {
                self.config.rules.locality.mode = match self.config.rules.locality.mode.as_str() {
                    "off" => "warn".to_string(),
                    "warn" => "error".to_string(),
                    "error" => "off".to_string(),
                    _ => "warn".to_string(),
                };
            }
            _ => {}
        }
    }
    
    fn edit_number(&self, item: &ConfigItem) -> Result<Option<usize>> {
        // Simple inline number editor
        // For now, just increment/decrement with arrow keys
        // Press Enter to confirm, Esc to cancel
        
        let current = self.get_number(item);
        let mut value = current;
        
        loop {
            // Show current value
            execute!(
                stdout(),
                cursor::MoveTo(40, self.selected as u16 + 1),
                Clear(ClearType::UntilNewLine),
                Print(format!("[{}] ←→", value))
            )?;
            stdout().flush()?;
            
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Left => {
                        if value > 1 {
                            value -= 1;
                        }
                    }
                    KeyCode::Right => {
                        value += 1;
                    }
                    KeyCode::Enter => {
                        return Ok(Some(value));
                    }
                    KeyCode::Esc => {
                        return Ok(None);
                    }
                    _ => {}
                }
            }
        }
    }
    
    fn get_number(&self, item: &ConfigItem) -> usize {
        match item {
            ConfigItem::MaxTokens => self.config.rules.max_file_tokens,
            ConfigItem::MaxComplexity => self.config.rules.max_cyclomatic_complexity,
            ConfigItem::MaxNesting => self.config.rules.max_nesting_depth,
            ConfigItem::MaxArgs => self.config.rules.max_function_args,
            ConfigItem::LocalityMaxDistance => self.config.rules.locality.max_distance,
            _ => 0,
        }
    }
    
    fn set_number(&mut self, item: &ConfigItem, value: usize) {
        match item {
            ConfigItem::MaxTokens => self.config.rules.max_file_tokens = value,
            ConfigItem::MaxComplexity => self.config.rules.max_cyclomatic_complexity = value,
            ConfigItem::MaxNesting => self.config.rules.max_nesting_depth = value,
            ConfigItem::MaxArgs => self.config.rules.max_function_args = value,
            ConfigItem::LocalityMaxDistance => self.config.rules.locality.max_distance = value,
            _ => {}
        }
    }
}

fn checkbox(checked: bool) -> String {
    if checked { "[x]".to_string() } else { "[ ]".to_string() }
}

/// Entry point for the config command
pub fn run_config_editor() -> Result<()> {
    let config = Config::load();
    let mut editor = ConfigEditor::new(config);
    
    if let Some(new_config) = editor.run()? {
        new_config.save()?;
        println!("Configuration saved.");
    } else {
        println!("Configuration unchanged.");
    }
    
    Ok(())
}
```

### New Config Fields

**File: `src/config/types.rs`**

Add new preference fields:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Preferences {
    // ... existing fields ...
    
    /// Write fix packet to file instead of clipboard
    #[serde(default)]
    pub write_fix_packet: bool,
    
    /// File path for fix packet (default: slopchop-fixme.txt)
    #[serde(default = "default_fix_packet_path")]
    pub fix_packet_path: String,
    
    /// Auto-promote on green verification
    #[serde(default)]
    pub auto_promote: bool,
}

fn default_fix_packet_path() -> String {
    "slopchop-fixme.txt".to_string()
}
```

### CLI Integration

**File: `src/cli/mod.rs`**

Add the config command:

```rust
#[derive(Subcommand)]
pub enum Commands {
    // ... existing commands ...
    
    /// Interactive configuration editor
    Config,
}
```

**File: `src/cli/handlers.rs`**

Add the handler:

```rust
pub fn handle_config() -> Result<()> {
    crate::cli::config_ui::run_config_editor()
}
```

**File: `src/bin/slopchop.rs`**

Wire it up:

```rust
Commands::Config => handlers::handle_config(),
```

### Testing

1. Run `slopchop config`
2. Navigate with arrow keys
3. Toggle booleans with Enter
4. Edit numbers with left/right arrows
5. Save with 'S', cancel with Esc
6. Verify `slopchop.toml` is updated

### Acceptance Criteria

- [ ] `slopchop config` opens interactive editor
- [ ] Arrow keys navigate between items
- [ ] Enter toggles booleans, edits numbers
- [ ] 'S' saves, Esc cancels
- [ ] Changes persist to `slopchop.toml`
- [ ] Works on Windows, macOS, Linux
- [ ] No ratatui dependency
- [ ] < 250 lines of code

---

## Feature 3: Configurable Output Mode (Part of Fix Packet)

### Problem

Some users may not have clipboard access (SSH, headless servers) or prefer file-based workflows.

### Solution

Add a config option to write the fix packet to a file instead of clipboard.

### Implementation

In `src/apply/messages.rs`:

```rust
pub fn print_ai_feedback(ai_message: &str) {
    let config = Config::load();
    
    println!("\n{}", "↩ Paste this back to the AI:".cyan().bold());
    println!("{ai_message}");
    
    if config.preferences.write_fix_packet {
        let path = &config.preferences.fix_packet_path;
        if let Err(e) = std::fs::write(path, ai_message) {
            eprintln!("Could not write fix packet to {path}: {e}");
        } else {
            println!("{}", format!("Fix packet written to: {path}").dimmed());
        }
    }
    
    if config.preferences.auto_copy {
        let _ = crate::clipboard::copy_to_clipboard(ai_message);
    }
}
```

---

## File Summary

### Files to Create

| File | Purpose | Lines (est) |
|------|---------|-------------|
| `src/cli/config_ui.rs` | Interactive config editor | ~200 |

### Files to Modify

| File | Change |
|------|--------|
| `src/cli/mod.rs` | Add `Config` command variant |
| `src/cli/handlers.rs` | Add `handle_config()` |
| `src/bin/slopchop.rs` | Wire up config command |
| `src/config/types.rs` | Add new preference fields |
| `src/apply/verification.rs` | Add `generate_ai_feedback()` |
| `src/apply/executor.rs` | Call feedback generation on failure |
| `src/apply/messages.rs` | Support file output mode |
| `Cargo.toml` | Ensure crossterm is not optional |

---

## Execution Order

1. **Fix paste-back** (30 min)
   - Add `generate_ai_feedback()` to verification.rs
   - Wire it into executor.rs failure path
   - Test with intentional failure

2. **Add config fields** (15 min)
   - Add `write_fix_packet`, `fix_packet_path`, `auto_promote` to Preferences
   - Update messages.rs to respect config

3. **Create config UI** (2-3 hrs)
   - Create `src/cli/config_ui.rs`
   - Wire up CLI command
   - Test on all platforms

4. **Polish** (30 min)
   - Update help text
   - Add to README
   - Update Changelog

---

## Success Criteria

v1.3.4 is complete when:

1. ✅ Verification failures auto-copy AI feedback to clipboard
2. ✅ `slopchop config` opens interactive editor
3. ✅ Config changes persist to `slopchop.toml`
4. ✅ Optional file output mode works
5. ✅ All tests pass
6. ✅ Works on Windows, macOS, Linux
7. ✅ No new dependencies added
8. ✅ Total new code < 300 lines

---

## Context for AI Implementation

When implementing, read these files first:
- `src/apply/messages.rs` - Existing AI feedback handling
- `src/apply/verification.rs` - Where failures are detected
- `src/apply/executor.rs` - Orchestrates the apply flow
- `src/config/types.rs` - Config structure
- `src/clipboard/mod.rs` - Clipboard utilities

The crossterm dependency is already present (used by ratatui which is optional). Make sure to use it directly, not through ratatui.

Keep the implementation minimal. The old TUI was deleted for being bloated. This config UI should be <250 lines and use only crossterm primitives.
