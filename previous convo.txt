# SlopChop God-Tier Audit: Session Summary & Roadmap

## What We Did This Session

### Starting State
The "god tier" audit system was **60% implemented but 0% working**:
- AST diffing code existed but never ran
- Parameterization inference existed but never ran
- Code generation existed but produced garbage
- Integration in `enhance.rs` silently failed at every step

### Root Cause
The pipeline broke at step 1: `named_descendant_for_point_range()` couldn't find function nodes because line ranges didn't align with AST boundaries. Every `?` operator after that silently swallowed the failure.

### Fixes Applied
1. **Node lookup**: Replaced fragile point-range lookup with recursive search by function name + line range
2. **Raw strings**: Added `raw_string_literal` to diff.rs and parameterize.rs (Rust uses `r#"..."#`)
3. **Codegen rewrite**: New `generate_consolidated_plan()` that:
   - Takes function names from the cluster
   - Infers enum name from prefixes (`q_*` â†’ `QueryKind`, `test_*` â†’ `TestCase`)
   - Generates proper variant names (`q_complexity` â†’ `Complexity`)

### Current Output
```
ðŸ¤– GOD TIER PLAN:
â”‚ // These 4 functions are structurally identical.
â”‚ // Consolidate into one function with an enum parameter:
â”‚
â”‚ #[derive(Debug, Clone, Copy)]
â”‚ pub enum QueryKind {
â”‚     Complexity,
â”‚     Imports,
â”‚     Defs,
â”‚     Exports,
â”‚ }
â”‚
â”‚ // Unified function signature:
â”‚ pub fn query(&self, kind: QueryKind) -> &'static str {
â”‚     match (self, kind) {
â”‚         (Self::Rust, QueryKind::Complexity) => todo!(),
â”‚         ...
â”‚     }
â”‚ }
â”‚
â”‚ // Delete these functions: q_complexity, q_imports, q_defs, q_exports
```

---

## What's Missing for True God-Tier

### 1. Full Function Bodies (HIGH VALUE)
**Current**: `todo!()` placeholders
**Goal**: Actual extracted match arms with the real string literals
```rust
// CURRENT
(Self::Rust, QueryKind::Complexity) => todo!(),

// GOD TIER
(Self::Rust, QueryKind::Complexity) => r#"
    (if_expression) @branch
    (match_arm) @branch
    ..."#,
```

**Implementation**: The diff already captures the variant values in each `Hole`. We just need to thread them through to codegen.

### 2. Call Site Updates (HIGH VALUE)
**Current**: Nothing
**Goal**: Show exactly how to update each call site
```rust
// BEFORE (found at src/metrics.rs:47)
lang.q_complexity()

// AFTER
lang.query(QueryKind::Complexity)
```

**Implementation**: `callsites.rs` already exists and finds usages via tree-sitter queries. Need to:
1. Run it for each function in the cluster
2. Generate before/after snippets
3. Include in the plan output

### 3. Source Markers (MEDIUM VALUE)
**Current**: Nothing
**Goal**: Point to exact differences like rustc errors
```rust
pub fn q_complexity(&self) -> &'static str {
         ^^^^^^^^^^^^
pub fn q_imports(&self) -> &'static str {
         ^^^^^^^^^
// These function names vary - extract to enum parameter
```

**Implementation**: The diff holes have path info. Map back to source positions and render with carets.

### 4. Visual Diff (QUESTIONABLE VALUE)
**What it would be**: Side-by-side comparison of two functions showing matching/differing parts
```
q_complexity                    â”‚ q_imports
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
pub fn q_complexity(           â”‚ pub fn q_imports(
       ^^^^^^^^^^^^            â”‚        ^^^^^^^^^
    &self                      â”‚     &self
) -> &'static str {            â”‚ ) -> &'static str {
    match self {               â”‚     match self {
        Self::Rust => r#"      â”‚         Self::Rust => r"
                      ^^^      â”‚                       ^^
            (if_expression)    â”‚             (use_declaration)
            ^^^^^^^^^^^^^^^    â”‚             ^^^^^^^^^^^^^^^^^
```

**Is this useful?** Honestly, probably not. You already KNOW they're similar (that's why they're flagged). The value is in the REFACTORING PLAN, not visualizing the similarity. This is "nice to have" but low ROI.

---

## Would This Be Useful Without AI?

**YES.** Here's why:

### Current State (needs AI)
```
slopchop audit â†’ "these 4 functions are similar" â†’ paste to Claude â†’ get refactoring
```

### God-Tier State (standalone tool)
```
slopchop audit â†’ complete refactoring code you can copy-paste or apply
```

The god-tier output would include:
1. **The enum definition** - copy into your types
2. **The unified function** - copy to replace the duplicates
3. **Call site changes** - find/replace or apply as patch
4. **Delete list** - remove the old functions

This makes slopchop a **standalone refactoring tool** like `rustfmt` or `clippy --fix`. The AI just becomes optional for edge cases.

---

## Recommended Priority

1. **Full function bodies** - Highest impact, makes output actually usable
2. **Call site updates** - Second highest, completes the refactoring story
3. **Source markers** - Nice for understanding, medium effort
4. ~~Visual diff~~ - Skip unless bored

---

## Files Involved
```
src/audit/
â”œâ”€â”€ enhance.rs      # Integration (FIXED)
â”œâ”€â”€ diff.rs         # AST comparison (WORKS)
â”œâ”€â”€ parameterize.rs # Strategy inference (WORKS)
â”œâ”€â”€ codegen.rs      # Plan generation (NEEDS: bodies, callsites)
â”œâ”€â”€ callsites.rs    # Usage finder (EXISTS, needs integration)
â””â”€â”€ display.rs      # Visual output (EXISTS, unused)
```

## Next Session Starting Point

1. Show me `diff.rs` - need to see how holes store variant values
2. Show me `callsites.rs` - need to integrate call site finding
3. Update `codegen.rs` to emit full bodies using hole data
4. Add call site section to plan output
